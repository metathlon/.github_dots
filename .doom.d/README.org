

* Índice
#+BEGIN_QUOTE
- [[#Sobre-esta-configuración][Sobre esta configuración]]
  - [[#Función-load-user-file][Función load-user-file]]
- [[#Basic-Doom-settings][Basic Doom settings]]
  - [[#Fuente][Fuente]]
  - [[#Theme][Theme]]
  - [[#Dashboard-con-imágen][Dashboard con imágen]]
  - [[#Lexical-binding][Lexical binding]]
- [[#Emacs-basics][Emacs basics]]
  - [[#Gestión-de-claves][Gestión de claves]]
  - [[#Shell][Shell]]
  - [[#Idioma-español][Idioma español]]
- [[#use-package][use-package]]
- [[#Multi-edit][Multi-edit]]
- [[#Multi-cursor][Multi-cursor]]
- [[#Org-mode][Org-mode]]
  - [[#Core][Core]]
    - [[#Carga-básica][Carga básica]]
    - [[#Secuencia-TO-DO][Secuencia TO-DO]]
    - [[#Secuencia-prioridades][Secuencia prioridades]]
    - [[#Exports][Exports]]
  - [[#Org-capture][Org-capture]]
    - [[#Cerrado-de-frames-tras-la-captura][Cerrado de frames tras la captura]]
    - [[#Templates-genéricos][Templates genéricos]]
  - [[#Org-contacts][Org-contacts]]
    - [[#Variables][Variables]]
    - [[#Template-de-captura][Template de captura]]
  - [[#Org-Tempo][Org-Tempo]]
  - [[#Org-Babel][Org-Babel]]
  - [[#Org-Log][Org-Log]]
  - [[#Tablas][Tablas]]
    - [[#Checkbox-en-tabla][Checkbox en tabla]]
  - [[#Agenda][Agenda]]
    - [[#Basic-config][Basic config]]
    - [[#Primer-día-de-la-semana][Primer día de la semana]]
    - [[#Mostrar-solo-un-día][Mostrar solo un día]]
  - [[#Super-Agenda][Super-Agenda]]
    - [[#Hook][Hook]]
    - [[#Vista-personalizada][Vista personalizada]]
  - [[#Calendario][Calendario]]
    - [[#TODO-Cosas-que-faltan][TODO Cosas que faltan]]
    - [[#Org-Caldav][Org-Caldav]]
- [[#Mu4e][Mu4e]]
  - [[#Base][Base]]
  - [[#Contextos][Contextos]]
  - [[#Capturar-correo-con-org-mode][Capturar correo con org-mode]]
  - [[#Mandar-correos-con-HTML-o-archivos][Mandar correos con HTML y/o archivos]]
    - [[#Org-msg][Org-msg]]
    - [[#Renderizar-correos-con-HTML][Renderizar correos con HTML]]
  - [[#Imágenes-en-los-mensajes][Imágenes en los mensajes]]
  - [[#Alertas][Alertas]]
  - [[#Ejemplo-de-configuración-personal][Ejemplo de configuración personal]]
- [[#Contactos][Contactos]]
- [[#Flyspell][Flyspell]]
- [[#Editor][Editor]]
  - [[#Número-de-linea][Número de linea]]
  - [[#Área-seleccionada][Área seleccionada]]
  - [[#Disable-scroll-bar][Disable scroll bar]]
  - [[#Confirm-kill-process][Confirm kill process]]
  - [[#Actualización-de-cambios-externos-en-archivos][Actualización de cambios externos en archivos]]
  - [[#Marcado-de-paréntesis][Marcado de paréntesis]]
  - [[#Incluir-guión-bajo-como-parte-de-la palabra][Incluir _ (guión bajo) como parte de la palabra]]
  - [[#Histórico][Histórico]]
- [[#Keybindings][Keybindings]]
  - [[#Globales][Globales]]
    - [[#Org-Capture][Org-Capture]]
  - [[#Grupos-de-acceso-rápido-personales][Grupos de acceso rápido personales]]
    - [[#Setup][Setup]]
    - [[#C-1-car-map][C-1 -> car-map]]
    - [[#C-2-car-org-map][C-2 -> car-org-map]]
#+END_QUOTE


* Sobre esta configuración
Esta configuración está hecha con trozos vistos/robados/modificados de otras
partes (demasiadas para ser nombradas).

El sistema que usa es =literate=, una forma de programar *dentro* de archivos de
texto. Está claro que no es un sistema adecuado para *programar* pero yo diría
que para archivos de configuración complicados como este o tutoriales... lo
clava.

Uno de los problemas que tiene literate es el =lexical-binding= que es un
sistema visibilidad de variables un poco particular. Para poder usar archivos
externos con mi configuración personal (no quiero datos personales en github) me
he creado una función que expande los nombres de los archivos y *debo* usar
load-babel para cargarlos.

La función:

** Función load-user-file
#+BEGIN_SRC emacs-lisp
(defun load-user-file (file)
  (interactive "f")
  "Load a file in current user's configuration directory"
  (org-babel-load-file (expand-file-name file "~/.doom.d/"))
)
#+END_SRC

De ahora en adelante cuando quiera cargar un archivo de configuración personal
solo tengo que poner =(load-user-file "archivo.el")= y listo
* Basic Doom settings
** Fuente
#+BEGIN_SRC emacs-lisp
(when (member "Source Code Pro" (font-family-list))
  (setq doom-font (font-spec :family "Source Code Pro" :size 14)))
#+END_SRC

** Theme
#+BEGIN_SRC emacs-lisp
(setq doom-theme 'doom-one)
#+END_SRC

** Dashboard con imágen
Reemplazar el DOOM ascii por una imagen
#+BEGIN_SRC emacs-lisp
(add-hook! '(+doom-dashboard-mode-hook)
           (setq fancy-splash-image "~/dotfiles/emacs/doom.d/images/crypto.png"))
#+END_SRC

** Lexical binding
Se que es un sistema de scope de variables... yo que se
#+BEGIN_SRC emacs-lisp
;;; init.el -*- lexical-binding: t; -*-
#+END_SRC
* Emacs basics
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :preface
  (defvar caronte/indent-width 4)
  :config
  (setq
   ring-bell-function        'ignore       ; minimise distraction
   frame-resize-pixelwise    t
   default-directory         "~/"
   confirm-kill-emacs        nil
   )

  (tool-bar-mode -1)
  (menu-bar-mode -1)

  ;; better scrolling experience
  (setq scroll-margin 0
        scroll-conservatively 10000
        scroll-preserve-screen-position t
        auto-window-vscroll nil)

  ;; increase line space for better readability
  (setq-default line-spacing 3)

  ;; Always use spaces for indentation
  (setq-default indent-tabs-mode nil
                tab-width caronte/indent-width))
#+END_SRC
** Gestión de claves
Hay cosas que requieren claves, como el calendario, correo... esta configuración
indica si queremos que emacs las guarde para que no esté pidiendolas
constantemente.

#+BEGIN_SRC emacs-lisp
(setq plstore-cache-passphrase-for-symmetric-encryption t)
#+END_SRC

** Shell
#+BEGIN_SRC emacs-lisp
(setq shell-file-name "bash")
#+END_SRC

** Idioma español
#+BEGIN_SRC emacs-lisp
(setq current-language-environment "Spanish")
(setq org-export-default-language "es")
#+END_SRC
* use-package

Decirle a =use-package= que siempre ceda ante otros paquetes a menos que se le
diga lo contrario.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'use-package
  (setq use-package-always-defer t
        use-package-verbose t
        use-package-expand-minimally t
        use-package-compute-statistics t
        ;; use-package-enable-imenu-support t
        ))
#+END_SRC
* Multi-edit

#+BEGIN_SRC emacs-lisp

(require 'evil-multiedit)

;; Highlights all matches of the selection in the buffer.
(define-key evil-visual-state-map "R" 'evil-multiedit-match-all)

;; Match the word under cursor (i.e. make it an edit region). Consecutive presses will
;; incrementally add the next unmatched match.
(define-key evil-normal-state-map (kbd "M-d") 'evil-multiedit-match-and-next)
;; Match selected region.
(define-key evil-visual-state-map (kbd "M-d") 'evil-multiedit-match-and-next)
;; Insert marker at point
(define-key evil-insert-state-map (kbd "M-d") 'evil-multiedit-toggle-marker-here)

;; Same as M-d but in reverse.
(define-key evil-normal-state-map (kbd "M-D") 'evil-multiedit-match-and-prev)
(define-key evil-visual-state-map (kbd "M-D") 'evil-multiedit-match-and-prev)

;; OPTIONAL: If you prefer to grab symbols rather than words, use
;; `evil-multiedit-match-symbol-and-next` (or prev).

;; Restore the last group of multiedit regions.
(define-key evil-visual-state-map (kbd "C-M-D") 'evil-multiedit-restore)

;; RET will toggle the region under the cursor
(define-key evil-multiedit-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

;; ...and in visual mode, RET will disable all fields outside the selected region
(define-key evil-motion-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

;; For moving between edit regions
(define-key evil-multiedit-state-map (kbd "C-n") 'evil-multiedit-next)
(define-key evil-multiedit-state-map (kbd "C-p") 'evil-multiedit-prev)
(define-key evil-multiedit-insert-state-map (kbd "C-n") 'evil-multiedit-next)
(define-key evil-multiedit-insert-state-map (kbd "C-p") 'evil-multiedit-prev)

;; Ex command that allows you to invoke evil-multiedit with a regular expression, e.g.
(evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)

#+END_SRC

* Multi-cursor
#+BEGIN_SRC emacs-lisp
;============================================================================================
;          MULTICURSOR
;============================================================================================
(define-key evil-normal-state-map (kbd "<M-f3>") 'evil-mc-make-all-cursors)

#+END_SRC
* Org-mode
** Core
*** Carga básica
En esta carga básica incluimos los archivos que tendrá la agenda. Para indicar
qué archivos tendrá debemos dar la ruta y ahí es donde nos encontramos un
problema con que esto esté en un repositorio publico, no queremos una ruta como
=/archivos/tu_usuario_dropbox/archivo.org= por ejemplo, es por esto que he
creado un archivo de *configuración personal* que *no* será subido a github.

A pesar de todo mi =org.personal.config.el= contiene algo como:
#+BEGIN_SRC emacs-lisp
;; (setq caronte/org-agenda-directory = "~/DIR_ORG/")
;; (setq caronte/org-agenda-FILE- (concat caronte/org-agenda-directory "archivo_personal.org"))
#+END_SRC

El archivo estaría lleno de esas declaraciones, lo que me permite referirme a
ellas en el resto del documento como
=caronte/org-agenda-FILE-calendario-personal=, pongo el /FILE/ para que se
diferencie claramente de otras cosas (funciones o variables) que pueda haber en
el namespace /caronte/

#+BEGIN_SRC emacs-lisp
(load! "org.personal.config.el") ;; Carga de variables con rutas personales

(after! org
  (require 'find-lisp)
  (require 'org-capture)
  (require 'org-agenda)
  (def-package! org-contacts)

  ;; (load! "org.personal.config.el")
  (setq org-directory caronte/org-directory)
  (setq org-archive-location
       (concat org-directory "/ARCHIVADOS/%s_ARCHIVADO::datatree/")
    )
)
#+END_SRC

*** Secuencia TO-DO
Esta parte igual debería mejorarla, estos estados son pocos y no muy
descriptivos. Quizás estados separados para diferentes tipos de archivo... algo
para pensar
#+BEGIN_SRC emacs-lisp
(after! org
    (setq org-todo-keywords
        '(
        (sequence "TODO(t)" "STARTED(s)" "|" "DONE(d)" "CANCELED(c)")
        )
    )

    (setq org-todo-keyword-faces
        '(
        ("TODO" . (:foreground "yellow" :weight bold))
        ("STARTED" . (:foreground: "green" :weight bold))
        ("CANCELED" . (:foreground "yellow" :background "red" :weight bold))
        ("DONE" . (:foreground "grey" :weight bold))
        )
   )
)

#+END_SRC

*** Secuencia prioridades
Al final no me ha hecho falta pero como lo investigué en su momento... por si
hiciera falta en el futuro.

#+BEGIN_SRC emacs-lisp
;; (after! org
    ;; --- Configuración de PRIORIDADES
    ;; (setq org-highest-priority ?A)
    ;; (setq org-default-priority ?B)
    ;; (setq org-lowest-priority ?C)
;;)
#+END_SRC

*** Exports
**** LaTeX
***** Limpieza
Intento que la exportación de documentos a LaTeX no deje mierda por ahí, pero de
momento no he tenido éxito

#+BEGIN_SRC emacs-lisp
(after! org
    (setq org-latex-logfiles-extensions '("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl"))
    (setq org-latex-remove-logfiles t)
)
#+END_SRC

** Org-capture
*** Cerrado de frames tras la captura
En el proceso de captura se suelen abrir frames para introducir información,
queremos que esos frames se cierren cuando se finalice el proceso o se interrumpa.

#+BEGIN_SRC emacs-lisp
(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Pide a capture-finalize que cierre el frame"
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Pide a capture-destroy que cierre el frame"
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))
#+END_SRC

*** Templates genéricos

#+BEGIN_SRC emacs-lisp
;;=========================================================================
;;              Perfiles de captura
;;=========================================================================
(after! org
    (setq org-capture-templates
    '(
        ("t" "To Do Item" entry (file caronte/org-agenda-FILE-tareas)
        "* TODO %^{Description} %^{Tipo: | :trabajo: | :personal: }\n%U\n%?" :prepend t)
        ("r" "Receta Manual" entry (file caronte/org-agenda-FILE-recetas)
        "* %^{Recipe title: }\n  :PROPERTIES:\n  :source-url:\n  :servings:\n  :prep-time:\n  :cook-time:\n  :ready-in:\n  :END:\n** Ingredients\n   %?\n** Directions\n\n")
        ;; ("R" "Receta Automatica" entry (file caronte/org-agenda-FILE-recetas)
        ;;  "%(org-chef-get-recipe-from-url)" :empty-lines 1)
        ;; ("i" "org-protocol-capture" entry (file caronte/org-agenda-FILE-inbox)
        ;;  "* TODO [[%:link][%:description]]\n\n %i" :immediate-finish t)
        ("e" "email" entry (file caronte/org-agenda-FILE-emails)
        "* TODO %^{Descripcion_Breve} [#C] EMAIL: %a\nFROM: %:from:\nSUBJECT: %:subject\n%U\n" :clock-in t :clock-resume t)
        ;; "* TODO %^{Descripcion_BREVE} [#A] Reply: %a\n%U" :prepend t)
        ;; ("l" "Link" entry (file+headline caronte/org-agenda-FILE-links "LINKS")
        ;;   "* %? %^L %^g \n%T" :prepend t)

        )
    )
)
#+END_SRC
** Org-contacts
*** Variables
Definición de variables básicas

#+BEGIN_SRC emacs-lisp
(after! org
    (setq caronte/org-contacts-FILE (concat caronte/org-agenda-directory "CONTACTOS.org"))
    (setq caronte/org-imported-contacts-FILE (concat caronte/org-agenda-directory "CONTACTOS-IMPORTADOS.org"))
    (setq org-contact-files '(caronte/org-contacts-FILE))
)
#+END_SRC
*** Template de captura
#+BEGIN_SRC emacs-lisp
(after! org
    (add-to-list 'org-capture-templates
             '("C" "Contacto" entry (file caronte/org-contacts-FILE)
                  "* %^{Nombre}
                  :PROPERTIES:
                  :ADDRESS: %^{Direccion}
                  :BIRTHDAY: %^{yyyy-mm-dd}
                  :EMAIL: %^{correo}
                  :PHONE: %^{Telefono}
                  :NOTE: %^{NOTE}
                  :TAGS: %^{Relacion: | :familia | :amigo | :conocido | :trabajo }
                  :NICK: %^{NICK}
                  :END:
               ")
     )
)
#+END_SRC
** Org-Tempo
Cuando quieres usar snippets personalizados para código y usarlos como
=<s-<TAB>=... tienes que activar =org-tempo=

#+BEGIN_SRC emacs-lisp
    ;; TODO: esto no funciona del todo bien, habrá que revisar los trigger estos, creo que no lo estoy usando bien
    ;; (defun caronte/r-src-snippet )
(require 'org-tempo)
(after! org
    (add-to-list 'org-structure-template-alist '("r" . "src R :results output"))
)
#+END_SRC
** Org-Babel
Al parecer =org-babel-do-load-languages= es redundante con emacs Doom, pero no
se cómo incluir R en los lenguajes que controla babel. Tendré que mirarlo.

#+BEGIN_SRC emacs-lisp
;; (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((R . t)
;;    (latex . t)))
#+END_SRC

** Org-Log
#+BEGIN_SRC emacs-lisp
;;=========================================================================
;;              ORG-LOG
;;=========================================================================
(after! org
    ;; Guarda cuando se ha terminado una tarea
    (setq org-log-done 'time)
    ;; Guarda cuando se ha cambiado la fecha de una tarea
    (setq org-log-reschedule 'time)
    ;; Guarda cuando se ha cambiado la ubicación de una tarea (de un archivo a otro)
    (setq org-log-refile 'time)
    ;; Guarda cuando se ha cambiado la fecha limite de una tarea
    (setq org-log-redeadline 'time)
)
#+END_SRC

** Tablas
*** Checkbox en tabla
Estoy buscando un sistema para poder poner checkbox como estas:
- [ ] Sin marcar
- [X] Marcada

En las tablas, pero esto *no funciona* por lo menos de momento.

#+BEGIN_SRC emacs-lisp
;;=========================================================================
;;             Checkbox para tabla
;;=========================================================================
(defun check-cell ()
  (interactive)
  (let ((cell (org-table-get-field)))
    (if (string-match "[[:graph:]]" cell)
        (org-table-blank-field)
      (insert "X")
      (org-table-align))
    (org-table-next-field)))
#+END_SRC
** Agenda

Hay un par de cosas a tener en cuenta en esta sección. Si quieres una agenda
/normal/ en la que se ve varios días, te interesa saber qué día es el primero de
la semana, para indicarle a la agenda que te saque de lunes a domingo, por
ejemplo.

Yo la agenda no la uso para eso, yo me organizo en dos nieveles:
- Medio/Largo plazo: calendario
  Cuando tengo que programar algo que va a durar mucho tiempo (pero un lapso
  determinado, por ejemplo cursos que imparto que son varios días a la semana
  durante un par de meses), lo programo en el calendario y es allí donde voy a
  buscarlo. No son tareas complejas y la propia descripción es suficiente.

- Corto/Larguísimo: agenda
  El corto plazo, *hoy*, lo veo y gestiono mediante la agenda.
  El plazo larguísimo lo gestiono mediante TODOs que veo en la agenda, por
  ejemplo /Terminar de programar las funciones comunes de R/, esa tarea no tiene
  un plazo de fin determinado, pero quiero tenerla presente, por eso va con un
  TODO a la agenda.

Es por este sistema de organización por lo que yo uso una agenda en la que veo
*UN DIA*, hoy, y varias secciones de TODO. Por esto me da igual en qué día
comience la semana, es más, necesito que *NO esté indicado*, para evitar que me
muestre ESE día en vez de *hoy*.

*** Basic config
#+BEGIN_SRC emacs-lisp
  ;; -- Metemos en agenda TODOS los archivos que hay en el directorio que he configurado en org.persojnal.el
  ;; La idea es que ahí tendré los TODO de proyectos, asesoramientos, personales... y como todo son cosas que hay que hacer... pues tanto da
(after! org
  (setq org-agenda-files
        (find-lisp-find-files caronte/org-agenda-directory"\.org$"))
)
#+END_SRC
*** Primer día de la semana
#+BEGIN_SRC emacs-lisp
;; (after! org
;;     ;; --- si quieres que la semana empice en lunes
;;     (setq org-agenda-start-on-weekday 1)
;; )
#+END_SRC

*** Mostrar solo un día
#+BEGIN_SRC emacs-lisp
(after! org
    ;; --- si quieres que se muestre solo HOY
    (setq org-agenda-start-on-weekday nil)
    (setq org-agenda-start-day "+0d")
    (setq org-agenda-span 1)
)
#+END_SRC
** Super-Agenda
La configuración normal de la agenda es *una paliza*. Creo que todo lo que hace
la super-agenda puede hacerse con la agenda normal pero sería mucho más esfuerzo
del que estoy dispuesto a dedicar, así que es por eso que uso el paquete
[[github:https://github.com/alphapapa/org-super-agenda][org-super-agenda]]

Este módulo es un trabajo en proceso me temo.

*** Hook
#+BEGIN_SRC emacs-lisp
(add-hook! 'org-agenda-mode-hook org-super-agenda-mode)
#+END_SRC

*** Vista personalizada
Primero definimos =org-agenda-custom-view= para luego poder llamarlo

#+BEGIN_SRC emacs-lisp
(defun org-agenda-custom-view (&optional arg)
  (interactive "P")
  (org-agenda arg "z"))
#+END_SRC

Lo que pretendemos hacer es algo así, ejemplo de agenda

 MAXIMA PRIORIDAD:
 * tarea 1
 * tarea 2
 ========================
 AGENDA DEL DIA
 ========================
Otras tareas de menos prioridad:
 * tarea 3
 * tarea 4

 Uno de los problemas a los que nos enfrentamos es a separar las prioridades

**** Función de gestión de prioridades
Con esta función podemos separar las tareas según prioridad

#+BEGIN_SRC emacs-lisp
(defun air-org-skip-subtree-if-priority (priority)
  "Saltarse un subtree de la agenda si tiene una prioridad de PRIORIDAD

  PRIORIDAD puede ser uno de los siguientews valores ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

#+END_SRC

**** Función para la gestión de hábitos
De momento no estoy usando los /hábitos/ de org-mode. Pero por si los uso, he
encontrado una función que permite discriminarlos
#+BEGIN_SRC emacs-lisp
(defun air-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))
#+END_SRC

**** Vista personalizada
#+BEGIN_SRC emacs-lisp
(after! org
    (setq org-agenda-custom-commands
      '(("z" "Zuper Agenda!"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Hoy"
                                :time-grid t
                                :date today
                                ;; :todo "TODAY"
                                :scheduled today
                                :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '(
                          (:name "Siguiente"
                                 ;; :todo "NEXT"
                                 :scheduled future
                                 :order 1)
                          (:name "Fecha limite HOY"
                                 :deadline today
                                 :order 2)
                          (:name "Importante"
                                 ;; :tag "Important"
                                 :priority "A"
                                 :order 6)
                          (:name "Llegas TARDE"
                                 :deadline past
                                 :order 7)
                          (:name "Fecha limite proxima"
                                 :deadline future
                                 :order 8)
                          (:name "Assignments"
                                 :tag "Assignment"
                                 :order 10)
                          (:name "Issues"
                                 :tag "Issue"
                                 :order 12)
                          (:name "Projects"
                                 :tag "Project"
                                 :order 14)
                          (:name "Emacs"
                                 :tag "Emacs"
                                 :order 13)
                          (:name "Research"
                                 :tag "Research"
                                 :order 15)
                          (:name "Lista de libros a leer"
                                 :tag "Read"
                                 :order 30)
                          (:name "En espera"
                                 :todo "WAITING"
                                 :order 20)
                          (:name "trivial"
                                 :priority<= "C"
                                 :tag ("Trivial" "Unimportant")
                                 ;; :todo ("SOMEDAY" )
                                 :order 90)
                          (:name "Estadistica y metodología"
                                 :tag ("ESTADISTICA" "METODOLOGIA")
                                 :order 80
                                 )
                          (:discard (:tag ("Chore" "Routine" "Daily")))

                          ))))))))
)
#+END_SRC
** Calendario
Hay un par de formas de hacer esto y las he probado ambas. La *teoría* dice que
la combinación de =org-caldav= y =org-gcal= debería ser la ideal para configurar
calendarios de Google. En la práctica =org-gcal= a las 2 horas de funcionar me
daba siempre errores, al parecer excede el número de peticiones que hace a
Google o algo así.

El resumen es que con [[https://github.com/dengste/org-caldav][org-caldav]] me ha ido bien, no es el más rápido pero va
bien.
*** TODO Cosas que faltan
- [ ] Gestionar mejor cuando se sincronza, no estoy seguro de que la
  configuración actual sea la mejor
- [ ] Eliminar, suprimir, minimizar o yo que sé los *buffer de resultado de
  sincronización*. Son lo más irritante del mundo, especialmente cuando se ha
  sincronizado correctamente o cuando ha dado un error 400 porque el token vete
  a saber qué mierda le ha pasado al token.
- [ ] Evitar que SPC abra el día, me mata y lo odio. SPC que abra el desplegable
  de doom y RET que abra el día.
- [ ] Hacer que q mate del todo el calendario y si no hay otro buffer que
  muestre el dashboard

*** Org-Caldav
**** TODO Configuración básica
Hay que configurar el backup y gestionarlo, pero aún no tengo claro cómo
#+BEGIN_SRC emacs-lisp
    ;; (setq org-caldav-backup-file)
    (setq org-caldav-sync-changes-to-org "all")
    (setq cfw:org-overwrite-default-keybinding t)
    (setq org-icalendar-include-sexps t)
#+END_SRC
**** Configuración personal
Esta es la que no subo a github
#+BEGIN_SRC emacs-lisp
    (load! "org-caldav.personal.config.el")
#+END_SRC
***** Ejemplo del archivo de configuración personal
Para mostrar los diferentres calendarios uso [[github:https://github.com/kiwanami/emacs-calfw][emacs-calfw]] como se puede ver en
este ejemplo.
****** Base calfw
#+BEGIN_SRC emacs-lisp
;; (use-package! calfw
;;    :config
;;    (require 'calfw)
;;    (require 'calfw-org)
;;    (require 'calfw-ical)

;;    (defun caronte/open-calendar ()
;;    (interactive)
;;    (cfw:open-calendar-buffer
;;    :contents-sources
;;    (list
;;    ;; (cfw:org-create-source "Green")  ; orgmode source
;;    (cfw:ical-create-source "TRABAJO-COMPARTIDO" "URL-A-iCal-CALENDAR-URL" "IndianRed")
;;    (cfw:ical-create-source "TRABAJO-MIO" "https://calendar.google.com/calendar/ical/..../basic.ics" "green") ; google calendar ICS
;;    )))
;;    (setq cfw:org-overwrite-default-keybinding t)
;;  )
;;  (require 'calfw-gcal)
#+END_SRC

****** Base caldav
No he conseguido poder abstraer esta configuración de los literales, si pudiera
poner en variables lo correspondiente a =:files= y al =:calendar-id= estaría
genial porque solo necesitaría un fichero personal con esos nombres de
variables, lo que haría mucho MUCHO más sencilla la instalación y gestión de
esta configuración en github.

#+BEGIN_SRC emacs-lisp
    ;; (setq org-caldav-oauth2-client-id "xxxxxxxxxxxx.apps.googleusercontent.com")
    ;; (setq org-caldav-oauth2-client-secret "xxxxxxxxxxxxxxxxxxx")
    ;;
    ;; La siguiente linea SE SUPONE que es para guardar las contraseñas y no tener que ponerlas mil veces
    ;; Además de que YA la tengo puesta (al principio del archivo), caldav no la respeta
    ;; no se como arreglarlo pero mu4e si que respeta el setting pero caldav no
    ;; (setq plstore-cache-passphrase-for-symmetric-encryption t)
    ;; (setq org-caldav-url 'google)
#+END_SRC

En la siguiente lista meteremos tantos calendarios como queramos, solo hay que
copiar y pegar.
#+BEGIN_SRC emacs-lisp
    ;; (setq org-caldav-calendars
    ;;     '(
    ;;     ;;----------------------------------------------------------------------------------------
    ;;     ;; Calendario basico asignado a ORG-MODE
    ;;     ;; ---------------------------------------------------------------------------------------
    ;;     (:calendar-id "xxxxxxxxxxxxxxx@group.calendar.google.com"
    ;;                 :files ("~/xxxxxxx/ORG/ACTIVOS/GCAL_ORG_MODE_events.org" )
    ;;                 :inbox "~/xxxxxxx/ORG/ACTIVOS/GCAL_ORG_MODE_events_inbox.org"
    ;;     )
    ;; )
#+END_SRC
****** Capture templates
De estos tengo uno por cada calendario que gestiono
#+BEGIN_SRC emacs-lisp
;; --- Calendaro ORG-MODE
;; (add-to-list 'org-capture-templates
;; 	  '("p" "GCal ORG-MODE" entry (file caronte/org-agenda-FILE-calendario-personal)
;; 	    "* %?\n:PROPERTIES:\n:calendar-id: xxxxxxxx@group.calendar.google.com\n:END:\n:org-gcal:\nSCHEDULED:%^T\n:END:\n")
;; )
#+END_SRC

**** Sincronización (que no nos pase nada)
Esto es todo un proceso... lo que quiere decir que odio esta parte y no estoy
seguro de qué quiero hacer con ella
***** Funcion de sicronización a la salida
Esta sería la función que usaría para guardar buffers y sincronizar el
calendario al salir, pero lo cierto es que no la uso porque normalmente no
gestiono el calendario desde aquí y sobre todo porque cuando cierro QUIERO
CERRAR.

La /solución/ que he encontrado es syncronizar cuando guardo un .org, lo que
tiene sus propios problemas, pero no me quejo.
#+BEGIN_SRC emacs-lisp
;; This is the sync on close function; it also prompts for save after syncing so
;; no late changes get lost
(defun org-caldav-sync-at-close ()
  (org-caldav-sync)
  (save-some-buffers))
#+END_SRC

***** Sincronización por tiempo
#+BEGIN_SRC emacs-lisp
;; This is the delayed sync function; it waits until emacs has been idle for
;; "secs" seconds before syncing.  The delay is important because the caldav-sync
;; can take five or ten seconds, which would be painful if it did that right at save.
;; This way it just waits until you've been idle for a while to avoid disturbing
;; the user.
;; ==================================================================================
;; La ultima linea NORMALMENTE debería ser:
;;   (* 1 secs) nil 'org-caldav-sync)))
;;
;; En esta config se ha cambiado org-caldav-sync por org-gcal-syn
;; El motivo es que gcal se encarga de mandar eventos desde los archivos ORG a los calendarios
;; caldav (que se encarga de mostrar en un calendario los que ya hay en google calendar) usa otro sistema, los ics
;; y se sincronizan con abrir el propio calendario
;;
;; Así que me estoy aprovechando del sistema de timer de caldav para sincronizar gcal en realidad

(defvar org-caldav-sync-timer nil
    "Timer that `org-caldav-push-timer' used to reschedule itself, or nil.")
(defun org-caldav-sync-with-delay (secs)
  (when org-caldav-sync-timer
    (cancel-timer org-caldav-sync-timer))
  (setq org-caldav-sync-timer
  (run-with-idle-timer
    (* 1 secs) nil 'org-caldav-sync)))

#+END_SRC
***** Sincronización tras guardar archivo .org
#+BEGIN_SRC emacs-lisp
(after! org
    (add-hook 'after-save-hook
        (lambda ()
        (when (eq major-mode 'org-mode)
    (org-caldav-sync-with-delay 3))))
)
#+END_SRC

***** Siconrización al cerrar emacs
#+BEGIN_SRC emacs-lisp
;; (add-hook 'kill-emacs-hook 'org-caldav-sync-at-close)
#+END_SRC

***** Sincronización al entrar en la agenda
#+BEGIN_SRC emacs-lisp
;; (add-hook 'org-agenda-mode-hook 'org-caldav-sync)
#+END_SRC

***** Sincronización "personalizada"
De momento no está personalizada pero creo que por aquí anda el secreto de matar
el resultado de la sincronización, que lo odio a muerte

#+BEGIN_SRC emacs-lisp
(defun caronte/org-caldav-sync nil
    "Sincronizar CalDAV"
    'org-caldav-sync)
#+END_SRC

***** Org-icalendar
De momento esta sección tampoco la estoy usando
#+BEGIN_SRC emacs-lisp
    ;; (setq org-icalendar-alarm-time 1)
    ;; This makes sure to-do items as a category can show up on the calendar
    ;; (setq org-icalendar-include-todo t)
    ;; This ensures all org "deadlines" show up, and show up as due dates
    ;; (setq org-icalendar-use-deadline '(event-if-todo event-if-not-todo todo-due))
    ;; This ensures "scheduled" org items show up, and show up as start times
    ;; (setq org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))
#+END_SRC
**** Teclas
#+BEGIN_SRC emacs-lisp
    ;; (define-key car-map (kbd "s") 'org-caldav-sync)
    (setq cfw:org-overwrite-default-keybinding t)
    (defvar cfw:org-custom-map
    (cfw:define-keymap
    '(
        ("g"   . cfw:refresh-calendar-buffer)
        ("j"   . cfw:org-goto-date)
        ("k"   . org-capture)
        ("q"   . doom-dashboard/open)
        ("d"   . cfw:change-view-day)
        ("v d" . cfw:change-view-day)
        ("v w" . cfw:change-view-week)
        ("v m" . cfw:change-view-month)
        ("x"   . cfw:org-clean-exit)
        ("RET" . cfw:org-open-agenda-day)
        ))
    "Key map for the calendar buffer.")
#+END_SRC
* Mu4e
Mucha de la configuración del correo implica datos personales, para evitar
subirlos he separado la configuración entre /genérica/ y /personal/.
** Base
#+BEGIN_SRC emacs-lisp

(require 'smtpmail)

(after! mu4e
    (defvar mu4e-main-mode-map
        (let ((map (make-sparse-keymap)))
        ;; (define-key map "b" 'mu4e-headers-search-bookmark)
        ;; (define-key map "B" 'mu4e-headers-search-bookmark-edit)
        ;; (define-key map "s" 'mu4e-headers-search)
        (define-key map "q" 'mu4e-quit)
        (define-key map "j" 'mu4e~headers-jump-to-maildir)
        )
    )
    (load! "mu4e.personal.config.el")
    (setq message-kill-buffer-on-exit t
        mu4e-attachment-dir              "~/Descargas/MU4E_ATTACHMENTS/"
        mail-user-agent 'mu4e-user-agent
        mu4e-index-update-in-background t
        mu4e-compose-signature-auto-include t
        mu4e-use-fancy-chars t
        mu4e-view-show-addresses t
        mu4e-view-show-images t
        mu4e-sent-messages-behavior 'sent
        ;; mu4e-compose-format-flowed t
        ;; mu4e-compose-in-new-frame t
    )
)
#+END_SRC



#+BEGIN_SRC emacs-lisp

;; ==========================================================================
;; --------- configuracion de correo ----------------------------------------
;; ==========================================================================
;; La configuracion del coreo se ha pasado a mu4e.config para "anonimizar"
;; En este directorio se puede encotrar un ejemplo de la configuracion:
;; ejemplo.mu4e.config.el
;; -------------------------------------------------------------------------
;; PARA ARREGLAR EL MENU PRINCIPAL
(remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view)


;; Cargamos nuestra configuración particular
;; (load! "mu4e.config.el")
;; (define-key car-map (kbd "m") 'mu4e)
;; Creo que esto solucionará el que se active el org-mu4e-compose-org-mode
(remove-hook 'mu4e-compose-mode-hook 'org-mu4e-compose-org-mode)
#+END_SRC

** Contextos
Como tengo configuradas multiples cuentas uso contextos (ver ejemplo de
configuración personal), por esto tengo que indicar qué contexto será el
/default/

#+BEGIN_SRC emacs-lisp
(after! mu4e
  (setq mu4e-context-policy 'pick-first)
)
#+END_SRC

** Capturar correo con org-mode
#+BEGIN_SRC emacs-lisp
(defun caronte/org-capture-email ()
    (interactive)
    (org-capture nil "e"))
(define-key mu4e-headers-mode-map (kbd "c") 'caronte/org-capture-email)
#+END_SRC

** Mandar correos con HTML o archivos
*** Org-msg
Es un problema lo del HTML y lo de los archivos, antes de hacer esto tenía que
montar un follón, ahora solo he instalado [[github:https://github.com/jeremy-compostella/org-msg][org-msg]] y usas los comandos normales de
tu gestor de correo y las cosas pasan

C-c C-c: enviar
C-c C-a: attach

#+BEGIN_SRC emacs-lisp
(require 'org-msg)
(after! org
    (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil"
        org-msg-startup "hidestars indent inlineimages"
        org-msg-greeting-fmt "\nHola %s,\n\n"
        org-msg-greeting-name-limit 1
        org-msg-text-plain-alternative t
        ;; org-msg-signature caronte/org-msg-signature
    )
)

(org-msg-mode)
#+END_SRC

*** Renderizar correos con HTML

#+BEGIN_SRC emacs-lisp
(setq mu4e-html2text-command 'mu4e-shr2text)
(defvar caronte/mu4e~view-html-images t
  "Intentar mostrar imágenes en mensaje HTML")

(defun caronte/mu4e-view-toggle-html-images ()
  "Toggle el ver imágenes en el HTML."
  (interactive)
  (setq-local caronte/mu4e~view-html-images (not caronte/mu4e~view-html-images))
  (message "Images are %s" (if caronte/mu4e~view-html-images "on" "off"))
  (mu4e-view-refresh))


(defun mu4e-shr2text (msg)
  "Transformar el codigo HTML del mensaje a texto usando el motor shr;
   Esto es lo que usaremos para configurar `mu4e-html2text-command'.
   Based on code by Titus von der Malsburg."

  (lexical-let ((view-images caronte/mu4e~view-html-images))
    (mu4e~html2text-wrapper
      (lambda ()
      (let ((shr-inhibit-images (not view-images)))
        (shr-render-region (point-min) (point-max)))) msg)))

(define-key mu4e-view-mode-map "i" 'caronte/mu4e-view-toggle-html-images)
(setq mu4e-html2text-command 'mu4e-shr2text)

#+END_SRC

** Imágenes en los mensajes
Activarlas o no
#+BEGIN_SRC emacs-lisp
(setq mu4e-view-show-images t)
#+END_SRC

Si imagemagick está instalado usarlo para mostrarla
#+BEGIN_SRC emacs-lisp
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))

#+END_SRC

** Alertas
Tengo que pensar cómo hacerlo de momento he cogido este código de algún sitio,
pero no lo veo claro

#+BEGIN_SRC emacs-lisp
;; (setq mu4e-alert-interesting-mail-query
;;     (concat
;;      "flag:unread maildir:/Exchange/INBOX "
;;      "OR "
;;      "flag:unread maildir:/Gmail/INBOX"
;;      ))
;; (mu4e-alert-enable-mode-line-display)
;; (defun caronte-refresh-mu4e-alert-mode-line ()
;;   (interactive)
;;   (mu4e~proc-kill)
;;   (mu4e-alert-enable-mode-line-display)
;;   )
;; (run-with-timer 0 60 'caronte-refresh-mu4e-alert-mode-line)

#+END_SRC

** Ejemplo de configuración personal
en este mismo repositorio hay un archivo que se llama =ejemplo.mu4e.config.el=
que muestra un ejemplo de cómo sería la configuración "personal"

** Contactos
#+BEGIN_SRC emacs-lisp
;;===========================================================================
;;---------------------------------------------------------------------------
;;     Contactos correo
;;---------------------------------------------------------------------------
;;===========================================================================
;; (setq mu4e-org-contacts-file (concat caronte/org-agenda-directory "CONTACTOS.org"))
(setq mu4e-org-contacts-file org-contacts-files)
(add-to-list 'mu4e-headers-actions
  '("org-contact-add" . mu4e-action-add-org-contact) t)
(add-to-list 'mu4e-view-actions
  '("org-contact-add" . mu4e-action-add-org-contact) t)


#+END_SRC
* Flyspell
Gestor ortográfico para múltiples modos de emacs

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook (lambda() (flyspell-mode)))
(add-hook 'mu4e-compose-mode-hook (lambda() (flyspell-mode)))
;; (add-hook 'org-mode-hook 'turn-on-flyspell)
;; (add-hook 'org-mode-hook 'turn-on-auto-fill)
;; (add-hook 'mu4e-compose-mode-hook 'turn-on-flyspell)
;; (add-hook 'mu4e-compose-mode-hook 'turn-on-auto-fill)
#+END_SRC
* Editor
** Número de linea
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type t)
#+END_SRC
** Área seleccionada
En emacs por defecto cuando resaltas un área con el editor en modo visual, ese
área se queda marcada a la espera de que hagas algo con ella. Pero no es eso lo
que pasa en los editores normalmente. Normalmente marcas un área y haces algo, o
no, y si escribes en otra parte del documento esa selección se pierde.

Este es un comportamiento al que ya estoy muy hecho y por lo tanto lo prefiero
en emacs también:

#+BEGIN_SRC emacs-lisp
(use-package delsel
  :disabled
  :ensure nil
  :config (delete-selection-mode +1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq delete-selection-mode t)
#+END_SRC

** Disable scroll bar
Usamos las teclas para todo, no es como que vaya a darle con el ratón a la barra
de scroll, así que lo mejor es quitarla.

#+BEGIN_SRC emacs-lisp
(use-package scroll-bar
  :defer t
  :ensure nil
  :config (scroll-bar-mode -1))
#+END_SRC

** Confirm kill process
Hay varios paquetes que generan /procesos/ dentro de emacs (como python, la
sincronización de calendario, etc etc etc). Cuando cierras si alguno de estos
procesos está activo te pide confirmación. No quiero tener que confirmar 100
cosas cuando cierro el programa.

#+BEGIN_SRC emacs-lisp
(use-package files
  :defer t
  :config
  (setq confirm-kill-processes nil))
#+END_SRC

** Actualización de cambios externos en archivos
No es raro que yo edite cosas en varios sitios al mismo tiempo, con varias
sesiones de emacs, con vim, con lo que sea. El caso es que quiero que cuando
cambie algo fuera, si tengo ya abierto el archivo en un buffer, ese buffer se
actualice con el estado actual del fichero.

#+BEGIN_EXPORT emacs-lisp
(use-package autorevert
  :defer t
  :ensure nil
  :config
  (global-auto-revert-mode +1)
  (setq auto-revert-interval 2
        auto-revert-check-vc-info t
        auto-revert-verbose nil))
#+END_EXPORT

** Marcado de paréntesis

Por defecto tiene cierto retraso, creo que es para que no haya marcas volando
por ahí cuando mueves el cursor por el texto. Como fuere quiero que la marca de
paréntesis sea instantánea si es posible.
#+BEGIN_SRC emacs-lisp
(use-package paren
  :defer t
  :ensure nil
  :init (setq show-paren-delay 0.5)
  :config (show-paren-mode +1))
#+END_SRC

** Incluir guión bajo como parte de la palabra
Al contrario de vim, emacs trata cada parte de una palabra con guiones bajos (_)
como una palabra (al darle a w por ejemplo). Esto tiene sus cosas buenas y
malas, no estoy seguro de si quiero quitarlo pero por si acaso voy a dejar aquí
el código para hacerlo.

#+BEGIN_SRC emacs-lisp
;; (add-hook 'after-change-major-mode-hook
;;           (lambda ()
;;             (modify-syntax-entry ?_ "w")))
#+END_SRC

** Histórico
Control del histórico y limpieza del mismo

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :defer t
  :ensure nil
  :hook (after-init . recentf-mode)
  :custom
  (recentf-auto-cleanup "05:00am")
  (recentf-max-saved-items 200)
  (recentf-exclude '((expand-file-name package-user-dir)
                     ".cache"
                     ".cask"
                     ".elfeed"
                     "bookmarks"
                     "cache"
                     "ido.*"
                     "persp-confs"
                     "recentf"
                     "undo-tree-hist"
                     "url"
                     "COMMIT_EDITMSG\\'")))

;; When buffer is closed, saves the cursor location
(save-place-mode 1)

;; Set history-length longer
(setq-default history-length 500)
#+END_SRC
* Keybindings
** Globales
*** Org-Capture
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cc" 'org-capture)
#+END_SRC
** Grupos de acceso rápido personales
*** Setup
**** Limpiando de C-0 a C9
Lo primero es liberar algunas combianciones de teclas. He decidido hacer de C-1,
C-2, ... mis accesos rápidos. Así que limpiemos esas combinaciones de teclas
desde C-0 a C-9

#+BEGIN_SRC emacs-lisp

;; ==========================================================================
;; --------- Configuracion  de shortcuts personales --------------------------
;; ==========================================================================
;; lo primero es borrar las combiaciones C-1, C-2...
(dotimes (n 10)
  (global-unset-key (kbd (format "C-%d" n)))
  (global-unset-key (kbd (format "M-%d" n)))
)
#+END_SRC

**** Creando prefijos
Para poder usar estas combinaciones debemos crear un prefijo. Este es
básicamente el nombre del mapa de teclas asociado a ese grupo, por ejemplo, C-1
será car-map (un grupo genérico para lanzar aplicaciones) y C-2 será
car-org-map, un grupo para abrir directamente algunos archivos ORG de acceso habitual.

#+BEGIN_SRC emacs-lisp
;; ahora que tenemos "hueco" vamos a hacer nuestro propio mapa de atajos
(define-prefix-command 'car-map)
(global-set-key (kbd "C-1") 'car-map)
(define-prefix-command 'car-org-map)
(global-set-key (kbd "C-2") 'car-org-map)
;; estos atajos los voy a usar en otras partes, como el correo, la agenda, sitios así
#+END_SRC

*** C-1 car-map

**** Teclas
#+BEGIN_SRC emacs-lisp
;; -------------- AGENDA
(define-key car-map (kbd "a") 'org-agenda-custom-view )

;; -------------- NEOTREE
(define-key car-map (kbd "n") 'neotree)

;; -------------- CALENDAR
(define-key car-map (kbd "c") 'caronte/open-calendar)
    ;; (define-key car-map (kbd "s") 'org-caldav-sync)

;; -------------- MU4E
(define-key car-map (kbd "m") 'mu4e)
;; (define-key car-map (kbd "s") 'mu4e-headers-search)
(define-key mu4e-compose-mode-map (kbd "C-1 c") 'message-goto-cc)
(define-key mu4e-compose-mode-map (kbd "C-1 s") 'message-send-and-exit)

#+END_SRC

#+RESULTS:
: message-send-and-exit

*** C-2 car-org-map
**** Funciones
Si hacemos el bind directamente al archivo cuando presionamos C-2 lo que aparece
es:
1 - lambda
2 - lambda
a - lambda

Como esto es muy poco descriptivo usamos funciones de forma que lo que aparece
es:
1 - caronte/open-file-CONFIG
t - caronte/open-file-TAREAS

que es mucho más descriptivo

#+BEGIN_SRC emacs-lisp
(defun caronte/open-file-CONFIG()
  (interactive)
  (find-file "~/.doom.d/config.org")
)
(defun caronte/open-file-TAREAS ()
  (interactive)
  (find-file caronte/org-agenda-FILE-tareas)
)
(defun caronte/open-file-LINKS ()
  (interactive)
  (find-file caronte/org-agenda-FILE-links)
)
(defun caronte/open-file-EMAILS()
  (interactive)
  (find-file caronte/org-agenda-FILE-emails)
)
(defun caronte/open-file-RECETAS()
  (interactive)
  (find-file caronte/org-agenda-FILE-recetas)
)
(defun caronte/open-file-CALENDARIO-PERSONAL()
  (interactive)
  (find-file caronte/org-agenda-FILE-calendario-personal)
)
(defun caronte/open-file-CALENDARIO-TRABAJO()
  (interactive)
  (find-file caronte/org-agenda-FILE-calendario-trabajo)
)
(defun caronte/open-file-ESTADISTICA()
  (interactive)
  (find-file caronte/org-agenda-FILE-estadistica)
)
(defun caronte/open-file-ESTUDIOS()
  (interactive)
  (find-file caronte/org-agenda-FILE-estudios)
)
;; ------------- CONTACTOS ---
(defun caronte/open-file-CONTACTOS()
  (interactive)
  (find-file caronte/org-contacts-FILE)
)

#+END_SRC

**** Teclas
#+BEGIN_SRC emacs-lisp
(define-key car-org-map (kbd "1") 'caronte/open-file-CONFIG)
(define-key car-org-map (kbd "t") 'caronte/open-file-TAREAS)
;; (define-key car-org-map (kbd "l") 'caronte/open-file-LINKS)
;; (define-key car-org-map (kbd "e") 'caronte/open-file-EMAILS)
(define-key car-org-map (kbd "r") 'caronte/open-file-RECETAS)
;; (define-key car-org-map (kbd "c") 'caronte/open-file-CALENDARIO-PERSONAL)
;; (define-key car-org-map (kbd "C") 'caronte/open-file-CALENDARIO-TRABAJO)
(define-key car-org-map (kbd "e") 'caronte/open-file-ESTADISTICA)
(define-key car-org-map (kbd "d") 'caronte/open-file-ESTUDIOS)
;; ------------------------- CONTACTOS----------
(define-key car-org-map (kbd "c") 'caronte/open-file-CONTACTOS)
#+END_SRC





